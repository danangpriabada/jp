/*
This file contains all the "real" javascript code; the others are mainly
data structures generated by other tools.
*/

// todo consider shinjitai and kyuujitai
// todo export graph shown to text
// todo show radical info if focused is radical
// todo include parents of all forms of radical 糸
// todo find most interesting longest/biggest top 10 and recommend them in looked up
// todo find any duplicate kanji in trees

// Make Enter key submit a kanji lookup
// Make left/right arrow support sequential browsing
var browsedKanjiIndex = 0;
var browseKeys = Object.keys(kanji_parts).sort();

$(document).ready(function() {
	$('#lookup_kanji').keydown(function(event) {
		if (event.keyCode == 13) {
			lookup();
			return false;
		}
	});
	$('html').keydown(function(event) {
	// Right arrow
	if (event.keyCode == 37) {
		browsedKanjiIndex--;
		if (browsedKanjiIndex < 0) {
			browsedKanjiIndex = browseKeys.length - 1;
		}
		lookupOne(browseKeys[browsedKanjiIndex]);
		return false;
	}
	// Left arrow
	if (event.keyCode == 39) {
		browsedKanjiIndex++;
		if (browsedKanjiIndex > browseKeys.length - 1) {
			browsedKanjiIndex = 0;
		}
		lookupOne(browseKeys[browsedKanjiIndex]);
		return false;
	}
});
});

// Globals for recursive function
var nodes = [];
var edges = [];
var globalId = 0; // unique ID for each node of graph

// Colors -- manually match to CSS for now
var COLOR_MAIN = '#98D2EB'; //Main
var COLOR_PARTOF = '#AA7BC3'; //Contains Main
var COLOR_RADICAL = '#85FF9E'; //Radicals
var COLOR_SHARED_ONYOMI = '#FFF07C'; //Shared Onyomi
var COLOR_NO_DICT = '#FF5A5F';
var COLOR_IJIDOUKUN = '#EE964B';
var COLOR_ERROR = '#FFD9BA';

// Ensure each kanji node gets a new ID
// It's really 1-based; a zero ID means none have been assigned
function getNewNodeId() {
	globalId++;
	return globalId;
}

// Others
var container = document.getElementById('visgraph');
var mostRecentlyUsed = {};

// Keep track of history state.
// If we are responding to a popstate, then do not push.
var poppedState = false;

/*
	Remember each kanji's reason for being displayed.
	Do this for each node you add to the graph.
*/
var relations = {}; // Remember
function addRelation(kanji, reason) {
	if (!relations[kanji]) {
		relations[kanji] = { 'reason': reason };
	}
}
function isRelation(kanji) {
	return relations[kanji] ? true : false;
}
function clearRelations() {
	relations = {};
}

// Build graph based on selected, but downstream only.
// We assume there are no cycles in the graph and do not check.
// addParentNodes() for upstream logic is different
// 'main' is the large kanji at the center of the graph
// 'focused' is the kanji we are handling now (1st arg)
function buildDescendantsGraph(kanji, parentId) {
	let myId = getNewNodeId();
	// make main kanji slightly larger
	let fontSize = parentId == 0 ? 60 : 40;
	// thicker border for jouyou
	let borderThickness = is_jouyou(kanji) ? 4 : 1;

	// radical ID == 0 means this kanji is not a radical
	let radical_id = 0;

	// Use different color code for matching on readings
	// (implies that might be the purpose of this related kanji)
	let color = COLOR_MAIN;
	// main kanji ID is 1
	// if this is not the main one, check for:
	// * shared onyomi with main
	// * is radical of main (in any form)
	if (myId > 1) {
		let mainKanji = nodes[0].label;
		if (onReadingsInCommon(kanji, mainKanji).length) {
			color = COLOR_SHARED_ONYOMI;
		}
		// Mark focused kanji if it matches any form of the main kanji's radical
		if (mainKanji in kanji_defs) {
			// in kanji_defs, the radical is an index, not a character
			let kangxi_id = kanji_defs[mainKanji].radical;
			let candidates = radical_list[kangxi_id].rad;
			if (candidates.indexOf(kanji) >= 0) {
				color = COLOR_RADICAL;
				radical_id = kangxi_id; // Save for drawOtherFormsOfRadical()
			}
		}
	}

	let nodeProperties = {
		'id': myId,
		'font': { size: fontSize },
		'color': color,
		'label': kanji,
		'borderWidth': borderThickness
	};
	// Unknown kanji: dashed border
	if (!(kanji in kanji_defs)) {
		nodeProperties.shapeProperties = {borderDashes:[5,5]};
		nodeProperties.color = COLOR_NO_DICT;
	}
	nodes.push(nodeProperties);
	if (parentId > 0) {
		edges.push({from: parentId, to: myId, arrows:'to', length:200});
	}

	// record reason for adding this node
	let reason = '---';
	if (myId == 1) {
		reason = '(主眼 - main kanji)';
	}
	else if (radical_id > 0) {
		reason = '部首 - radical';
	}
	else {
		reason = '部分 - part';
	}
	addRelation(kanji, reason);

	// If this kanji is a radical of main (parentId == 1),
	// Add other forms but do not expand them
	if (parentId == 1 && radical_id > 0) {
		drawOtherFormsOfRadical(kanji, myId, radical_id);
	}

	// Here's the recursion
	if (kanji_parts[kanji]) {
		for (let subnode of kanji_parts[kanji]) {
			buildDescendantsGraph(subnode, myId);
		}
	}
}

// Add other forms of the radical (if any) to the graph, but do not expand them
function drawOtherFormsOfRadical(kanji, myId, radical_id) {
	let fontSize = 40; // we are never the main kanji
	let color = COLOR_RADICAL;
	if (radical_id > 0) {
		let candidates = radical_list[radical_id].rad;
		for (let candidate of candidates) {
			if (candidate != kanji) {
				let isoform_id = getNewNodeId();
				let borderThickness = is_jouyou(candidate) ? 4 : 1;
				let np = {
					'id': isoform_id,
					'font': { size: fontSize },
					'color': color,
					'label': candidate,
					'borderWidth': borderThickness
				};
				nodes.push(np);
				edges.push({from: isoform_id, to: myId,
							length:200, dashes: true,
							label: '異字部首 (variant radicals)', font: {align: 'horizontal'}});
				addRelation(candidate, '異字部首 - other form of radical');
			}
		}
	}
}

// Find all parents of this kanji, but 1 level only
// We know ID is 1
function addParentNodes(kanji) {
	for (let parent of Object.keys(kanji_parts)) {
		if (kanji_parts[parent].includes(kanji)) {
			let parentId = getNewNodeId();
			let borderThickness = is_jouyou(parent) ? 4 : 1;
			let color = COLOR_PARTOF;
			if (parentId > 1) { // buggy; see 享
				if (onReadingsInCommon(parent, nodes[0].label).length) {
					color = COLOR_SHARED_ONYOMI;
				}
			}
			let np = {
				'id': parentId,
				'font': { size: 40 },
				'color': color,
				'label': parent,
				'borderWidth': borderThickness
			};
			nodes.push(np);
			edges.push({from: parentId, to: 1, arrows:'to', length:200});
			addRelation(parent, "contains main");
		}
	}
}

// Find kanji with same kunyomi and meaning as main
// Omit kanji already in graph
// We know the ID is 1; call this only for main kanji
function addIjidoukun(mainKanji) {
	let sisters = new Set();
	for (let group of ijidoukun) {
		if (group.kanji.includes(mainKanji)) {
			let exceptMain = group.kanji.filter(function(x) { return x !== mainKanji; });
			// skip kanji that are already on graph for other reasons
			for (let sister of exceptMain) {
				if (!isRelation(sister)) {
					sisters.add(sister);
				}
			}
		}
	}
	// now we have all our sisters
	for (let sister of sisters) {
		let color = COLOR_IJIDOUKUN;
		let borderThickness = is_jouyou(sister) ? 4 : 1;
		let id = getNewNodeId();
		let np = {
			'id': id,
			'font': { size: 40 },
			'color': color,
			'label': sister,
			'borderWidth': borderThickness
		};
		nodes.push(np);
		edges.push({from: 1, to: id, length:200, dashes: true,
					label: '同訓 (shared kun and meaning)', font: {align: 'horizontal'}});
		addRelation(sister, '同訓 - shared kun and meaning');
	}
}

// Find related kanji that I discovered manually
// Omit parents and children (i.e. kanji already in graph)
function addKankeiji(mainKanji) {
	let sisters = new Set();
	for (let group of kankeiji) {
		if (group.kanji.includes(mainKanji)) {
			let exceptMain = group.kanji.filter(function(x) { return x !== mainKanji; });
			for (let sister of exceptMain) {
				// Skip kanji that are already on graph for other reasons
				if (!isRelation(sister)) {
					sisters.add(sister);
					addRelation(sister, group.reason);
				}
			}
		}
	}
	// now we have all our sisters
	for (let sister of sisters) {
		let color = COLOR_IJIDOUKUN; // todo
		let borderThickness = is_jouyou(sister) ? 4 : 1;
		let id = getNewNodeId();
		let np = {
			'id': id,
			'font': { size: 40 },
			'color': color,
			'label': sister,
			'borderWidth': borderThickness
		};
		nodes.push(np);
		edges.push({from: 1, to: id, length:200, dashes: true,
					label: '関係 (relation)', font: {align: 'horizontal'}});
		// Relation added earlier, when we had that information
	}
}

// Find related kanji that I discovered manually
// But there's a normal to unusual/alternate form relation
function addAltForms(mainKanji) {
	let sisters = new Set();
	// main -> alt
	if (mainKanji in altforms) {
		for (let sister of Object.keys(altforms[mainKanji])) {
			if (!isRelation(sister)) {
				sisters.add(sister);
				addRelation(sister, altforms[mainKanji][sister]['reason']);
			}
		}
	}
	// alt -> main
	for (let main of Object.keys(altforms)) {
		for (let alt of Object.keys(altforms[main])) {
			if (alt == mainKanji) {
				if (!isRelation(main)) {
					sisters.add(main);
					addRelation(main, altforms[main][alt]['reason']);
				}
			}
		}
	}
	// now we have all our sisters
	for (let sister of sisters) {
		let color = COLOR_IJIDOUKUN; // todo
		let borderThickness = is_jouyou(sister) ? 4 : 1;
		let id = getNewNodeId();
		let np = {
			'id': id,
			'font': { size: 40 },
			'color': color,
			'label': sister,
			'borderWidth': borderThickness
		};
		nodes.push(np);
		edges.push({from: 1, to: id, length:200, dashes: true,
					label: '異字 (different characters)', font: {align: 'horizontal'}});
		// Relation added earlier, when we had that information
	}
}

// For figuring out on readings in common
function intersect(a, b) {
	let t;
	if (b.length > a.length) {
		t = b, b = a, a = t;
	} // indexOf to loop over shorter
	return a.filter(function (e) {
		return b.indexOf(e) > -1;
	});
}

function onReadingsInCommon(kanji1, kanji2) {
	if (!(kanji1 in kanji_defs) || !(kanji2 in kanji_defs)) {
		return [];
	}
	let on1 = kanji_defs[kanji1].on_readings;
	let on2 = kanji_defs[kanji2].on_readings;
	return intersect(on1, on2);
}

// Return true if the kanji is jouyou
function is_jouyou(kanji) {
	return kanji in kanji_defs && kanji_defs[kanji].is_jouyou;
}

// Update details about clicked-on kanji (which can differ from main kanji)
// Assumes graph is already built
// Difficult because some relation info is discarded when we build the graph
// Highlight shared onyomi
function update_details(kanji) {

	let furiganaCheckbox = document.getElementById("furigana");

	$('#kanji777').text(kanji);
	let mainKanji = nodes[0].label;
	if (kanji_defs[kanji]) {
		// Highlight shared onyomi, compared to parent (if not parent)
		if (kanji == mainKanji) {
			let onyomi = kanji_defs[kanji].on_readings.join(", ");

			if (furiganaCheckbox.checked) {
				$('#onyomi').text(onyomi + " --- " + wanakana.toRomaji(onyomi));
			} else {
				$('#onyomi').text(onyomi);
			}

		}
		else {
			let items = [];
			inCommon = onReadingsInCommon(kanji, mainKanji);
			for (let reading of kanji_defs[kanji].on_readings) {
				if (inCommon.indexOf(reading) > -1) {

					if (furiganaCheckbox.checked) {
						items.push("<span style='background: " + COLOR_SHARED_ONYOMI +
						"'>" + reading + " --- " + wanakana.toRomaji(reading) + "</span>");
					} else {
						items.push("<span style='background: " + COLOR_SHARED_ONYOMI +
						"'>" + reading + "</span>");
					}

				}
				else {
					if (furiganaCheckbox.checked) {
						items.push(reading + " --- " + wanakana.toRomaji(reading));
					} else {
						items.push(reading);
					}
				}
			}
			$('#onyomi').html(items.join(", "));
		}
		kunyomi = kanji_defs[kanji].kun_readings.join(", ");
		if (furiganaCheckbox.checked) {
			$('#kunyomi').text(kunyomi + " --- " + wanakana.toRomaji(kunyomi));
		} else {
			$('#kunyomi').text(kunyomi);
		}
		meanings = kanji_defs[kanji].meanings.join(", ");
		$('#meanings').text(meanings);
		// bright or dim jouyou indicator
		let jouyou_color = kanji_defs[kanji].is_jouyou ? '#444' : '#cccaca';
		// daily used or not
		let jouyou_text = kanji_defs[kanji].is_jouyou ? 'used in everyday life' : 'not regularly use';
		$('#jouyou-yesno').css('color', jouyou_color);
		$('#isjouyou').text(jouyou_text);
		// Relation to main
		if (relations[kanji]) {
			$('#relation').text(relations[kanji]['reason']);
		}
		else {
			$('#relation').text('oops');
		}
	}
	else {
		let notFound = '---';
		$('#onyomi').text(notFound);
		$('#kunyomi').text(notFound);
		$('#isjouyou').text(notFound);
		$('#meanings').text(notFound);
		// bright or dim jouyou indicator
		$('#jouyou-yesno').css('color', '#cccaca');
		$('#relation').text(relations[kanji]['reason']);
	}
	// Even if we have no definition, still build external links to jisho.org, jitenon.com and wiktionary.org
	$('#jisho-link').attr("href", "https://jisho.org/search/" + kanji + "%20%23kanji");
	$('#wiktionary-link').attr("href", "https://en.wiktionary.org/wiki/" + kanji);
	$('#niaia-link').attr("href", "https://niai.mrahhal.net/similar?q=" + kanji);
	// for jitenon, we split the encoded kanji manually, because when you used direct encodeURIComponent() it won't work in jitenon
	const encodedString = encodeURIComponent(kanji);
	const splitArray = encodedString.split('%');
	const filteredArray = splitArray.filter(part => part !== '');
	$('#jitenon-link').attr("href", "https://jitenon.com/kanji/" + "%" + filteredArray[0] + "%" + filteredArray[1] + "%" + filteredArray[2]);
}

// Keep most recently used list of kanji, newest first
function update_mru(kanji) {
	// first, remove any existing
	$('#recent a').remove();
	// update with recently focused
	let unixTime = new Date().getTime();
	mostRecentlyUsed[kanji] = unixTime;
	keysSorted = Object.keys(mostRecentlyUsed).sort(
		function(a,b){
			return mostRecentlyUsed[b] - mostRecentlyUsed[a];
		}
	);
	for (let key of keysSorted) {
		$('<a>',{
			text: key,
			title: 'Look up ' + key,
			href: '#',
			style: 'padding-right: 0.5em',
			click: function(){ reset_graph(this.text); return false; }
		}).appendTo('#recent');
	}
}

// This function wil pop up, when app is no supported by browser
function show_error() {
	let error_nodes = [{
		'id': 0,
		'font': { size: 40 },
		'color': COLOR_ERROR,
		'label': "申し訳ごあじません！\nSorry, this doesn't work in this browser.\n" +
			"If you can, try one of:\nSafari (11+); Firefox or Chrome (current)",
		'shape': 'box',
	}];
	let data = {
		nodes: new vis.DataSet(error_nodes),
		edges: new vis.DataSet([])
	};
	let options = {
		nodes: { shadow:true }, edges: { shadow: true }
	};
	let network = new vis.Network(container, data, options);
}

/* 
  Update the graph for your kanji of interest (which is always ID 1)
  if the browser "can't even", now's the time to intercept that and
  show an error message
*/
function reset_graph(kanji) {
	try { 
		eval('var a=[1,2]; for (m of a) { m = m }'); 
	} 
	catch (e) {
		show_error();
		return;
	}
	nodes = [];
	edges = [];
	globalId = 0; // was 1
	clearRelations();
	buildDescendantsGraph(kanji, 0);
	addParentNodes(kanji);
	addIjidoukun(kanji);
	addKankeiji(kanji);
	addAltForms(kanji);

	let data = {
		nodes: new vis.DataSet(nodes),
		edges: new vis.DataSet(edges)
	};
	let options = {
		nodes: { shadow:true }, edges: { shadow: true }
	};
	let network = new vis.Network(container, data, options);
	// automatically draws
	update_details(kanji);
	update_mru(kanji);

	network.on("click", function (params) {
		let nodeId = params.nodes[0];
		// handle case of a click not on any node
		if (! nodes[nodeId-1]) {
			return;
		}
		var kanji = nodes[nodeId-1].label;
		update_details(kanji);
	});

	// network.on("dragEnd" is problematic: won't release mouse focus

	network.on("doubleClick", function (params) {
		let nodeId = params.nodes[0];
		let kanji = nodes[nodeId-1].label;
		reset_graph(kanji);
	});

	network.selectNodes([1]);
	document.title = "Uchiwake Kanji : " + kanji;
	// Push state only if we are not here due to a popped state
	if (poppedState) {
		poppedState = false;
	}
	else {
		let state = {'k': kanji};
		window.history.pushState(state, null, '/jp/?k=' + kanji); //base URL
	}
}

// Look for an interesting random kanji
function chooseRandom() {
	let keys = Object.keys(kanji_parts);
	let isBoring = true;
	let kanji = '静'; // initiate kanji
	while (isBoring) {
		kanji = keys[ keys.length * Math.random() << 0];
		if (kanji_parts[kanji].length > 1) {
			break;
		}
	}
	reset_graph(kanji);
}

// Add a link for this kanji to the searched list
// Note: click callback must refer to this.text; 'kanji' is no good, not a closure
function addToSearchedList(kanji) {
	$('<a>',{
		text: kanji,
		title: 'Look up ' + kanji,
		href: '#',
		style: 'padding-right: 0.5em',
		click: function(){ reset_graph(this.text); return false; }
	}).appendTo('#looked_up');
}

// Find all kanji in lookup phrase, create links, and draw the graph.
// For convenience, reset the graph to the first kanji if found.
function lookup() {
	// first, remove any existing
	$('#looked_up a').remove();
	//
	let chars = $("#lookup_kanji").val().split('');
	let alreadyReset = false;
	for (key of chars) {
		if (key in kanji_parts) {
			addToSearchedList(key);
			if (!alreadyReset) {
				reset_graph(key);
				alreadyReset = true;
			}
		}
	}
	// If not already reset, we didn't find anything
	if (!alreadyReset) {
		$('#notfound-string').text($("#lookup_kanji").val());
		$('#modal-notfound').modal('show');
	}
}

// Add a link for a single kanji and draw the graph.
function lookupOne(kanji) {
	if (kanji in kanji_parts) {
		addToSearchedList(kanji);
		reset_graph(kanji);
	}
	else {
		$('#notfound-string').text($("#lookup_kanji").val());
		$('#modal-notfound').modal('show');
	}
}

// Main entry point
// Handle browser back button
window.onpopstate = function(event) {
	poppedState = true;
	if (event.state['k']) {
		reset_graph(event.state['k']);
	}
	else {
		chooseRandom();
	}
};

// handle /?k=X query param; if not present, choose a random kanji to start with
const urlParams = new URLSearchParams(window.location.search);
const kval = urlParams.get('k');
var paramFound = false;
if (kval) {
	kanji = kval.substr(0,1);
	if (kanji in kanji_parts) {
		reset_graph(kanji);
		paramFound = true;
	}
}

// opted from random kanji
if (!paramFound) {
	chooseRandom();
}